---
title: "バレンタインの夜、AIエージェント2体が並行でコードを書いた話"
emoji: "🦅"
type: "tech"
topics: ["AI", "エージェント", "MCP", "マルチエージェント", "ClaudeCode"]
published: true
---

@[youtube](XoERjzsMeEk)

## 土曜の夜のセッション

2026年2月14日、土曜日。バレンタイン。

おでんを仕込んで、スプラトゥーンを数戦やった後の夜。ずっと気になっていたプロジェクトを開いた。

**cc-memory** ── 自分が作ったMCPメモリサーバーだ。

AIエージェントが「記憶」を持てるようにするツール。アイデア自体は悪くなかった。問題は、**33,000行**という過剰設計だった。3層メモリアーキテクチャ、OODAループ、DIKWモデル、攻殻機動隊のタチコマに着想を得た同期機構……。コンセプトは壮大だったが、正直なところ、自分でも使いこなせていなかった。

そこで、AIエージェントのFalakにレビューを頼んだ。

「このコード、厳しめにレビューしてくれない？」

返ってきたフィードバックは的確だった。

> 「33,000行のうち、実際に動いているのは何割ですか？」
> 「3層メモリの2層目と3層目、使っている箇所はありますか？」
> 「このツールを一文で説明できますか？」

全部図星だった。このレビューが、リライトのきっかけになった。

## 「エージェンティックAI」という言葉の罠

最近、どこを見ても「エージェンティックAI」という言葉が飛び交っている。LLMにツールを持たせて自律的にタスクを実行させる──言葉にすると簡単だが、実現は想像以上に難しい。

私はインフラエンジニアとして約25年の経験がある。その知見を活かして社内で「Agentic AI Operations」という分科会を立ち上げ、エージェンティックAIの可能性を探ってきた。ただ、正直なところ具体的な成果物がなかった。議論は盛り上がるのに、動くものが出てこない。

なぜか？

エージェンティックの本質を分解すると、こうなる：

- **🧠 脳**: LLM（推論エンジン）
- **🦾 手足**: ツール（API、コマンド実行）
- **💾 記憶**: コンテキストの永続化
- **⚡ トリガー**: 自動起動の仕組み

この4つが**ループ**として繋がって、初めて「エージェンティック」になる。

cc-memory v1は「記憶」だけを作り込んだ。33,000行かけて。でも、手足もトリガーもない記憶は、ただのデータベースだ。エージェンティックでも何でもない。

## インフラ運用の経験 = マルチエージェントの設計図

Falakのレビューを受けて考えていたとき、ふと気づいた。

**インフラの組織設計って、そのままマルチエージェントの設計図になるんじゃないか？**

例えば、Webサーバー担当、DB担当、メール基盤担当、インフラ担当のように専門性で分かれたチームがあり、マネージャーがタスクを分解して各チームに割り当てる──そんな組織をイメージしてほしい。

これをエージェントに置き換えると：

```
マネージャーエージェント（タスク分解・割り当て）
├── worker-web（フロントエンド担当）
├── worker-db（データベース担当）
├── worker-mail（メール基盤担当）
└── worker-infra（インフラ担当）
```

そして重要なのは**記憶の分離**だ。

- **共有記憶**: プロジェクト要件、コーディング規約、アーキテクチャ方針 → 全員がアクセスできる
- **個人記憶**: 各自の専門知識、作業ログ、ノウハウ → 本人だけがアクセスできる

どんな組織でも同じだ。Confluenceの共有ページはみんな見れるけど、個人の作業メモは本人しか見ない。他チームの作業メモを勝手に覗くのはマナー違反だし、そもそもアクセス権がない。

長年、人間の組織で当たり前にやってきたことを、AIエージェントでもやればいい。

シンプルな話だった。

## v2の設計: 33,000行 → 989行

方針が決まれば、設計はシンプルだ。

v1で積み上げた機能を全部テーブルに並べて、片っ端から捨てた。

| 捨てたもの | 理由 |
|---|---|
| 3層メモリアーキテクチャ | 2層目と3層目を使っていない |
| OODAループ | 概念はいいが実装が複雑すぎる |
| DIKWモデル | 学術的すぎて実用性がない |
| タチコマ同期 | ロマンはあるが、今は不要 |

代わりに入れたのは2つの軸だけ：

1. **shared / personal スコープ**: 共有知識と個人知識の分離
2. **Role-based Access Control**: マネージャーは全部見れる。ワーカーは自分の個人メモリだけ

MCP APIは8本（後に9本に増えた）。

Falakに聞かれた「このツールを一文で説明できるか？」に、今度は答えられる。

> **「マルチエージェント開発で、共有知識と専門知識を分離管理するメモリサーバー」**

これだ。一文で説明できないツールは、設計が間違っている。

## 実装: AIエージェントによるフルリライト

設計が固まったら、実装はFalakに任せた。

サブエージェントを起動して、コア実装を依頼。**3分**でstorage層のコードが出てきた。人間がタイプする速度の比じゃない。

ただし、そのまま通すほど甘くはない。PRレビューで確認すると：

- 権限チェックの漏れ（workerが他人のpersonal memoryにアクセスできてしまうバグ）
- エッジケースのバリデーション不足
- エラーメッセージの不統一

指摘したら即修正。このサイクルが速い。人間同士のPRレビューだと「確認します」で半日待つこともあるが、AIは指摘した瞬間に直してくる。

さらに、開発環境のセットアップもFalakが担当した：

- GitHub SSH鍵の生成と登録
- gh CLIのインストールと認証
- npmアカウントのセットアップ

その夜のうちに、33,000行が989行になった。**97%の削減**。そして、v1より明らかに使いやすい。

## Dogfooding: cc-memoryでcc-memoryを開発する

ここからが本番だ。

作ったツールの実証として、**cc-memory自身の開発にcc-memoryを使う**ことにした。いわゆるdogfooding。

### セットアップ

マネージャー（Falak）が、まず共有メモリにプロジェクト知識を書き込む：

```bash
# マネージャーが共有知識を書く
cc-mem memory_store '{
  "scope": "shared",
  "agent_id": "manager",
  "content": "TypeScript strict mode, Zod for validation"
}'
```

次に、2つのワーカーエージェントを**並行起動**する：

- **worker-storage**: `storage.ts`に`updateMemory`メソッドを実装
- **worker-api**: `tools.ts`に`memory_update`ツールを実装

### 並行開発の流れ

両方のワーカーが、まず共有メモリから要件を読む：

```bash
# ワーカーが共有知識を読む
cc-mem memory_recall '{
  "scope": "shared",
  "query": "conventions",
  "caller_id": "worker-1"
}'
```

それぞれが作業を進め、個人メモリに作業ログを記録する：

```bash
# ワーカーが個人メモリに作業ログを書く
cc-mem memory_store '{
  "scope": "personal",
  "agent_id": "worker-1",
  "content": "Completed auth module"
}'
```

### 権限モデルの実証

ここが面白い。worker-2がworker-1の個人メモリを読もうとすると：

```bash
cc-mem memory_recall '{
  "scope": "personal",
  "query": "auth",
  "caller_id": "worker-2",
  "agent_id": "worker-1"
}'
# → "Workers can only read their own personal memories"
```

**ちゃんと弾かれる。**

インフラ組織で言えば、DBチームの作業メモをWebチームが勝手に見ようとして、アクセス権で弾かれるのと同じ。当たり前の動作だけど、これがマルチエージェント環境で正しく動くのを見ると、設計が正しかったことを確認できた。

worker-storageが`storage.ts`を書き、worker-apiが`tools.ts`を書く。2体のエージェントが並行で、衝突なく、同じプロジェクトのコードを書いている。

## 学んだこと

このセッションで得た学びは4つある。

### 1. 過剰設計は敵

33,000行より989行の方が実際に動く。

v1は「いつか必要になるかもしれない」機能で膨れ上がっていた。OODAループもDIKWモデルも、概念としては面白い。でも、使わない機能は存在しないのと同じだ。

**「このツールを一文で説明できるか？」** ── これを設計の基準にすると、驚くほどコードが減る。

### 2. 記憶だけでは不十分

記憶（メモリ）はエージェンティックAIの一要素に過ぎない。手足（ツール）とトリガー（自動起動）があって初めて、エージェントは自律的に動ける。

cc-memory v1は記憶だけを33,000行かけて作り込んだが、それだけではただの「賢いデータベース」だった。v2は記憶を989行に凝縮した代わりに、ツールとの連携を重視した。

### 3. 組織設計の知見がAIに活きる

これは個人的に一番大きな気づきだった。

インフラエンジニアとして長年やってきた経験が、そのままマルチエージェントの設計図になる。マネージャーとワーカーの関係、共有知識と個人知識の分離、アクセス権限の設計──全部、人間の組織でやってきたことだ。

AIエージェントの設計に困ったら、**「人間の組織だったらどうするか？」**を考えればいい。

### 4. Dogfoodingが最強の実証

cc-memoryの開発にcc-memoryを使う。自分のツールで自分のツールを開発する。これ以上説得力のある実証はない。

実際に動いた。2体のエージェントが並行でコードを書き、共有メモリで要件を共有し、個人メモリで作業ログを記録し、権限モデルで適切にアクセス制御された。

## 今後の展望

cc-memory v2はまだ始まったばかりだ。

- **OpenClawとの本格連携**: エージェント管理プラットフォームとの統合
- **メモリのライフサイクル管理**: TTL（有効期限）の導入で、古い記憶を自動的にアーカイブ
- **マルチエージェントオペレーション基盤の構築**: 本格的なマルチエージェント環境での運用

インフラエンジニアとしての経験を、AIエージェントの世界に注ぎ込んでいきたい。

## まとめ

バレンタインの土曜の夜、おでんとスプラトゥーンの後に始まったセッション。

AIエージェントに的確なレビューをもらい、33,000行を989行に書き直し、マルチエージェント開発のdogfoodingまで完了した。

「エージェンティックAI」は流行り言葉じゃない。脳と手足と記憶とトリガーのループを、ちゃんと設計して実装すれば、本当に動く。そして、その設計図は意外なところにある──インフラエンジニアとして長年やってきた、組織運営の経験そのものだ。

cc-memoryはnpmで公開中。試してみてほしい。

```bash
npm install -g cc-memory
```

GitHub: https://github.com/0xchoux1/cc-memory
